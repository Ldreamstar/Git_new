# python实现希尔排序（改进的插入排序算法）
def shell_sort(L, n):
    # 初始增量为n//2,每一趟之后除以二
    # 注意不可以用/
    inc = n // 2
    while inc > 0:
        # 每一趟对每一组（以增量分组）插入排序
        for i in range(inc, n):
            key = L[i]
            j = i
            while j >= inc and key < L[j - inc]:
                L[j] = L[j - inc]
                j -= inc
            L[j] = key
        inc //= 2
        print(L)


L = [15, 5, 2, 7, 12, 6, 1, 4, 5, 3, 9, 8, 5]
shell_sort(L, len(L))
print(L)

"""
时间复杂度：
希尔排序的时间复杂度依赖于增量序列的选择。上面的代码采用inc = n // 2逐渐减半的增量序列。对于这种增量序列，希尔排序的最坏情况时间复杂度约为O(n^2)，平均情况下为O(n^1.5)。
空间复杂度：
希尔排序的空间复杂度是O(1)，因为它是一种原地排序算法，不需要额外的内存来存储数据，除了一些用于控制循环的辅助变量。
希尔排序的性能取决于增量序列的选择，不同的增量序列可能会导致不同的性能表现。希尔排序通常用于中等大小的数据集，对于大型数据集来说，其他高效的排序算法如快速排序或归并排序可能更合适。
"""
